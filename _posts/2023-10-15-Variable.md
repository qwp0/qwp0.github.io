---
title:  "변수"
categories: Js
published : true
typora-root-url: ../
author_profile: true
sidebar_main: true
---
## 변수란 ?
**변수(Variable)** : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.
### 변수가 필요한 이유
```javascript
 15 - 5;
 ```
자바스크립트 엔진이 위의 코드를 계산하려면 식의 의미를 해석하고 - 연산을 수행하기 위해 피연산자를 기억한다.
메모리 셀 하나의 크기는 1byte(8bit)로 1byte 단위로 데이터를 저장하고 읽어들인다. 컴퓨터는 모든 데이터를 2진수로 처리하기 때문에 메모리에고 2진수로 저장된다. 
위 식의 숫자 15과 5은 메모리 주소에 저장되고 CPU가 이 값으로 연산을 수행한 후 결과값 역시 메모리 주소에 저장된다.

여기서 연산 결과를 재사용하고 싶다면 연산 결과가 저장된 메모리 공간에 직접 접근해야한다. 하지만 메모리 주소를 통한 값에 대한 직접 접근은 시스템을 멈추게 하는 치명적인 오류를 발생시킬 수 있어 자바스크립트는 이를 허용하지 않는다.

그래서 기억하고 싶은 값을 메모리에 저장하고 저장된 값을 읽어들여 재사용하기 위해 변수가 필요하다.

> **식별자** : 어떤 값을 구별해서 식별할 수 있는 고유한 이름으로 값이 아니라 메모리 주소를 기억하고 있다.

즉, 식별자는 메모리 주소에 붙은 이름이라고 할 수 있고 변수 역시 식별자다.
## 변수 선언
변수를 생성하는 것. 즉, 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있도록 준비하는 것이다. 
확보된 메모리 공간에는 자바스크립트 엔진에 의해 undefined 값으로 암묵적으로 할당되어 초기화된다.

변수 선언할 때는 var,let,const 키워드를 사용한다.
```javascript
 var name;
 ```
var 키워드를 사용한 변수 선언은 선언과 초기화가 동시에 진행되서 변수 이름 name을 등록하고 name에 암묵적으로 undefined를 할당한다.

변수를 사용하려면 반드시 선언이 필요하며 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다.


## 변수 호이스팅
```javascript
 console.log(name); // undefined
 var name; // 변수 선언문
 ```
위의 코드에서 순차적으로 console.log(name)이 먼저 실행되고 변수 선언이 실행된다면 변수 선언 전에 식별자에 접근하는 것이기 때문에 ReferenceError가 발생할 것처럼 보이지만 undefined가 출력된다.

바로 **변수 호이스팅** 때문이다.
변수 호이스팅은 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점. 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되서 변수 선언문이 코드 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징이다.

## 값의 할당
```javascript
 console.log(name); // undefined
 var name;      // 변수 선언
 name = "소영"; // 값의 할당
 console,log(name); // "소영"
 ```
 변수 선언은 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.
 그렇기 때문에 위의 코드에서 선언을 통해 이미 undefined로 초기화되어 있어서 첫번째 줄은 undefined가 출력된다. name 변수에 값을 할당하면 name 변수의 값은 undefined에서 새롭게 할당한 값으로 변경되어 마지막 줄은 새로 할당한 값이 출력된다.

```javascript
 console.log(name); // undefined
 var name = "소영"; // 변수 선언과 값의 할당
 console,log(name); // "소영"
 ```
 변수 선언과 값의 할당을 동시에 해도 자바스크립트 엔진은 둘을 각각 나누어 실행하기 때문에 정확히 동일하게 동작한다.

 값을 할당할 때와 재할당할 때 모두 이전 값이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 새로운 값을 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 새로운 값을 저장한다.

 이때 이전 값들은 어떤 식별자와도 연결되어 있지 않게 되는데 이런 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다.
