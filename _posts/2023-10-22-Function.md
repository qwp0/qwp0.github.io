---
title: "[Deep Dive] 함수"
categories: Js
published: true
typora-root-url: ../
author_profile: true
sidebar_main: true
---

## 함수란?

> 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

입력을 받아서 출력을 내보낸다. 이 때 함수 내부로 입력을 전달받는 변수를 매개변수(parameter) , 입력을 인수(argument) , 출력을 반환값(return value)라고 한다. 또한 함수를 구별하기 위해 식별자인 함수 이름을 사용한다.

<img src="/images/2023-10-22-Function/function.png" alt="함수의 구성 요소" />

함수는 함수 정의를 통해 생성하고 함수 호출을 통해 실행된다.

```javascript
// 함수 정의
function add(x, y) {
  return x + y;
}

// 함수 호출
var result = add(3, 5);

// 함수 add네 인수 3,5를 전달하면서 호출하면 반환값 8을 반환한다.
console.log(result); // 8
```

## 함수를 사용하는 이유

> - 코드의 재사용성
> - 유지 보수의 편의성
> - 코드의 신뢰성
> - 코드의 가독성

## 함수 리터럴

> 자바스크립트의 함수는 객체 타입의 값이며 함수 리터럴로 생성할 수 있다.
> 함수 리터럴은 function 키워드 , 함수 이름 , 매개변수 목록 , 함수 몸체로 구성된다.

함수 리터럴은 평가되어 값을 생성하는데 이 값은 객체다. 즉, 함수는 객체다.
하지만 호출할 수 없는 일반 객체와 달리 호출할 수 있으며 함수 객체만의 고유한 프로퍼티를 갖는다.

## 함수 정의

> 함수 정의 방식에는 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수(ES6)가 있다.

### 함수 선언문

```javascript
function add(x, y) {
  return x + y;
}
```

함수 선언문은 함수 리터럴과 형태가 동일하지만 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다.

함수 선언문은 표현식이 아닌 문으로 변수에 할당할 수 없으나 함수 리터럴과 형태가 동일하기 때문에 함수 선언문이 변수에 할당되는 것처럼 보일 수 있다.

즉, 이름이 있는 기명 함수 리터럴은 코드의 문맥에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석된다.

이때, 함수 선언문으로 생성된 함수는 호출할 수 있으나 함수 리터럴 표현식으로 생성된 함수는 호출할 수 없다.

함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이므로 함수 외부에서 함수 이름으로 함수를 호출할 수 없다.(함수를 가리키는 식별자가 없음)
하지만 자바스크립트 엔진이 함수 선언문을 해석해 함수 객체를 생성하고 호출을 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하기 때문에 함수 선언문으로 생성된 함수는 함수 호출이 가능하다.

함수 선언문을 의사 코드로 표현하면 다음과 같다.

<img src="/images/2023-10-22-Function/function2.png" alt="식별자로 함수 호출" />

함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는 듯하지만 사실은 함수 객체를 가리키는 식별자로 호출된 것이다.

### 함수 표현식

자바스크립트 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 객체를 `일급 객체`라고 한다. 이는 함수를 값처럼 자유롭게 사용할 수 있다는 의미이다.

함수 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 정의 방식을 `함수 표현식`이라고 한다.

함수 리터럴의 함수 이름은 생략할 수 있고 이러한 함수를 익명 함수라고 한다.

함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 한다.

```javascript
var add = function foo(x, y) {
  return x + y;
};
//함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

//함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 호출하면 ReferenceError가 발생한다.
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```

### 함수 생성 시점과 함수 호이스팅

함수 선언문은 코드의 선두로 끌어 올려진 것처럼 동작한다. 이러한 자바스크립트 고유의 특징을 `함수 호이스팅`이라 한다.

함수 호이스팅은 변수 호이스팅과 차이가 있다.
var 키워드로 선언된 변수가 undefined로 초기화되는 것과 달리 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다.
따라서 var 키워드를 사용한 변수 선언문 이전에 변수를 참조하면 undefined로 평가되지만 함수 선언문으로 정의된 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출 가능하다.

함수 표현식은 변수에 할당하는 값이 함수 리터럴인 문이다.
따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.
함수 표현식 이전에 함수를 참조하면 undefined로 평가되고 이때 함수를 호출하면 undefined를 호출하는 것과 마찬가지로 타입 에러가 발생한다.

함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하기에 함수 선언문 대신 함수 표현식을 사용할 것을 권장한다.

### Function 생성자 함수

```javascript
var add = new Function("x", "y", "return x + y");
console.log(add(2, 5)); // 7
```

### 화살표 함수

ES6에서 도입된 화살표 함수는 function 키워드 대신 화살표를 사용해 좀 더 간략하세 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다.

```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

## 함수 호출

> 함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호춭한다.

### 매개변수와 인수

함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수를 통해 인수를 전달한다.

<img src="/images/2023-10-22-Function/function3.png" alt="매개변수와 인수" />

매개변수보다 인수가 부족한 경우의 매개변수의 값은 undefined이며 초과한 경우에는 무시된다.

### 반환문

함수는 return 키워드와 표현식으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있다.

함수 호출은 표현식이기 때문에 함수 호출 표현식은 return 키워드가 반환한 표현식의 평과 결과, 즉 반환값으로 평가된다.

출처 : 이웅모, 『모던 자바스크립트 deep dive』, 위키북스
